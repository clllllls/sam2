# SAM2 项目开发规范

## 引言

本文档旨在为SAM2项目团队提供统一的开发规范和最佳实践指南。通过遵循这些规范，我们可以：

- 确保代码质量和一致性
- 提高团队协作效率
- 简化新成员的入职流程
- 促进项目的可维护性和可扩展性
- 建立清晰的责任和工作流程

本规范涵盖了项目的目录结构、命名约定、代码组织、配置管理、开发流程、测试策略和最佳实践等方面。所有参与SAM2项目开发的团队成员都应当熟悉并遵守这些规范。

## 适用范围

本规范适用于：
- 核心模型开发
- 训练脚本编写
- 演示应用开发
- 示例代码和文档维护
- 测试代码编写

## 规范更新和维护

本规范将根据项目发展和团队反馈定期更新。更新流程如下：
1. 提交规范变更建议
2. 团队讨论和评审
3. 更新文档
4. 通知所有团队成员

---

## 1. 目录结构规范

### 1.1 项目根目录结构

```
sam2-main/
├── sam2/                  # 核心模型代码
├── training/              # 训练相关代码
├── demo/                  # Web演示应用
├── notebooks/             # 示例代码和教程
├── checkpoints/           # 模型权重文件
├── dataset/               # 数据集存储
├── sav_dataset/           # SA-V数据集工具
├── tools/                 # 辅助工具脚本
├── assets/                # 静态资源文件
├── notebooks/             # Jupyter示例笔记本
└── tests/                 # 测试代码（如有）
```

### 1.2 核心目录功能说明

#### 1.2.1 sam2/
- **用途**: 包含所有模型定义和推理相关代码
- **结构**:
  - `configs/`: 模型配置文件，按版本组织（sam2、sam2.1等）
  - `modeling/`: 模型架构定义
    - `backbones/`: 骨干网络（如Hiera）
    - `sam/`: SAM基础组件
    - `sam2_base.py`: SAM2基础模型实现
  - `utils/`: 工具函数
  - `csrc/`: CUDA扩展
  - `*.py`: 主要的API接口文件（predictors等）
- **新增规则**: 
  - 新增模型组件应放在`modeling/`下相应子目录
  - 配置文件按版本和功能分类存放

#### 1.2.2 training/
- **用途**: 训练相关代码和配置
- **结构**:
  - `dataset/`: 数据集加载器和处理
  - `model/`: 训练相关的模型包装
  - `utils/`: 训练工具函数
  - `loss_fns.py`: 损失函数定义
  - `optimizer.py`: 优化器配置
  - `trainer.py`: 训练器实现
  - `training.yaml`: 训练配置文件
- **新增规则**:
  - 数据集处理代码统一放在`dataset/`目录
  - 训练配置文件采用YAML格式，存放在根目录

#### 1.2.3 dataset/
- **用途**: 存储项目数据集
- **结构**:
  - `images/`: 图像数据（训练时使用）
  - `json/`: 标注数据（JSON格式）
- **新增规则**:
  - 数据集应按功能分类存放
  - 大型数据集文件应通过文档说明下载方式，不直接包含在代码库中

#### 1.2.4 notebooks/
- **用途**: 提供使用示例和教程
- **结构**:
  - `*.ipynb`: Jupyter笔记本示例
  - `images/`: 示例用图像
  - `videos/`: 示例用视频
- **新增规则**:
  - 示例应包含详细注释和说明
  - 相关资源文件放在子目录中

#### 1.2.5 demo/
- **用途**: Web演示应用
- **结构**:
  - `backend/`: 后端服务
  - `frontend/`: 前端界面
  - `data/`: 演示数据
- **新增规则**:
  - 遵循前后端分离架构
  - 配置独立的依赖管理

### 1.3 目录创建标准

- **新目录命名**: 使用小写字母和下划线，避免连字符
- **目录层级**: 尽量控制在3-4层以内
- **功能单一**: 每个目录应有明确且单一的功能定位
- **避免冗余**: 避免创建与现有目录功能重叠的新目录
- **文档要求**: 新增目录应在README或相关文档中说明用途

## 2. 文件命名和代码组织规范

### 2.1 文件命名规范

- **Python文件命名规则**:
  - 使用小写字母和下划线组合（snake_case）
  - 文件名应清晰表达其功能或内容
  - 避免使用缩写，除非是广泛认可的术语
  - 示例：
    - `sam2_image_predictor.py` - SAM2图像预测器
    - `memory_attention.py` - 内存注意力机制
    - `vos_dataset.py` - 视频目标分割数据集加载器

- **配置文件命名规则**:
  - 使用YAML格式（.yaml扩展名）
  - 包含版本信息时使用点号分隔
  - 功能描述与模型规格明确
  - 示例：
    - `sam2.1_hiera_b+.yaml` - SAM2.1版本，Hiera骨干网络，b+规格
    - `training.yaml` - 训练配置文件

- **CUDA扩展命名规则**:
  - 与功能直接相关的命名
  - 保持简洁明了
  - 示例：
    - `connected_components.cu` - 连通组件分析
    - `custom_ops.cu` - 自定义操作

- **文档文件命名规则**:
  - 使用描述性名称
  - 使用连字符（-）分隔单词
  - 明确表明文档类型
  - 示例：
    - `installation-guide.md` - 安装指南
    - `developer-notes.md` - 开发者注意事项

### 2.2 类和函数命名

- **类命名规则**:
  - 使用帕斯卡命名法（PascalCase）
  - 类名应该是名词或名词短语
  - 接口可以使用I前缀
  - 示例：
    - `SAM2ImagePredictor` - SAM2图像预测器类
    - `MemoryAttentionLayer` - 内存注意力层
    - `SAM2Base` - SAM2基础模型类

- **函数和方法命名规则**:
  - 使用蛇形命名法（snake_case）
  - 函数名应该是动词或动词短语
  - 明确表达其行为和目的
  - 示例：
    - `build_sam2` - 构建SAM2模型
    - `predict_masks` - 预测掩码
    - `load_image` - 加载图像

- **变量命名规则**:
  - 使用蛇形命名法（snake_case）
  - 变量名应简洁明了，表达其含义
  - 避免使用单字母变量（循环计数器除外）
  - 示例：
    - `image_embedding` - 图像嵌入
    - `num_classes` - 类别数量
    - `output_dir` - 输出目录

- **常量命名规则**:
  - 使用全大写字母和下划线
  - 仅用于真正不变的值
  - 示例：
    - `DEFAULT_MODEL_CONFIG` - 默认模型配置
    - `MAX_IMAGE_SIZE` - 最大图像尺寸
    - `BATCH_SIZE` - 批处理大小

- **私有成员命名规则**:
  - 类的私有成员（方法和变量）前缀使用单个下划线
  - 表示内部实现细节，不应该被外部直接调用
  - 示例：
    - `_encode_prompts` - 内部方法：编码提示
    - `_feature_cache` - 内部变量：特征缓存

### 2.3 代码组织原则

- **模块化设计**:
  - 功能相关的代码组织到同一个文件或模块
  - 每个模块应有明确的职责边界
  - 避免过大的文件（单个文件不超过500行）

- **单一职责原则**:
  - 每个类或函数应该专注于单一功能
  - 一个方法应该只做一件事，并做好它
  - 避免过长的函数体（通常不超过50行）

- **依赖管理**:
  - 避免循环依赖
  - 包内部使用相对导入，如：`from .sam2_image_predictor import SAM2ImagePredictor`
  - 外部依赖通过`setup.py`或`requirements.txt`管理
  - 使用类型提示帮助IDE和静态分析工具

- **注释规范**:
  - **文档字符串格式**:
    ```python
    def predict_masks(self, image, prompts):
        """预测图像中对象的掩码
        
        Args:
            image: numpy数组，输入图像
            prompts: 提示信息，如点、框等
            
        Returns:
            masks: 预测的掩码结果
            
        Example:
            >>> masks = predictor.predict_masks(image, points=[[100, 150]])
        """
        # 实现代码
    ```
  
  - **类文档字符串**:
    ```python
    class SAM2ImagePredictor:
        """SAM2图像预测器，用于生成图像中对象的分割掩码
        
        该类提供了用户友好的接口，用于通过提示信息（点、框等）
        生成图像中对象的分割掩码。
        
        Attributes:
            model: 加载的SAM2模型
            device: 运行设备（CPU或CUDA）
        """
        # 类实现
    ```
  
  - **行内注释**:
    - 复杂逻辑或算法添加行内注释
    - 注释应简洁明了，解释"为什么"而非"是什么"
    - 使用中文进行注释（项目团队主要使用中文）

- **代码格式规范**:
  - 遵循PEP 8规范
  - 使用4个空格缩进（不使用制表符）
  - 行长度限制为120个字符
  - 导入语句按以下顺序组织：
    ```python
    # 标准库导入
    import os
    import sys
    
    # 第三方库导入
    import numpy as np
    import torch
    
    # 项目内部导入
    from sam2.modeling import build_sam2
    ```

- **异常处理规范**:
  - 明确捕获特定异常，避免使用裸露的`except:`
  - 提供有意义的错误信息
  - 在适当的级别处理异常，避免过早捕获
  - 示例：
    ```python
    try:
        model.load_state_dict(torch.load(checkpoint_path))
    except FileNotFoundError:
        raise FileNotFoundError(f"模型权重文件未找到: {checkpoint_path}")
    except RuntimeError as e:
        raise RuntimeError(f"加载模型权重失败: {str(e)}")
    ```

## 3. 配置管理规范

### 3.1 配置文件结构

- **使用Hydra**: 采用Hydra进行配置管理
- **配置格式**: YAML格式，支持层级结构和组合
- **配置组织**:
  - 模型配置放在`sam2/configs/`下按版本分类
  - 训练配置放在`training/`目录

### 3.2 配置项命名

- **使用小写**: 配置键使用小写字母和下划线
- **描述性命名**: 配置项名称应清晰表达其用途
- **类型一致**: 相同功能的配置项保持类型一致

### 3.3 配置示例

```yaml
model:
  _target_: sam2.modeling.sam2_base.SAM2Base
  image_encoder:
    _target_: sam2.modeling.backbones.image_encoder.ImageEncoder
    # 配置参数...
```

## 4. 数据集组织规范

### 4.1 数据集格式

- **图像数据**: 支持JPG、PNG格式
- **标注格式**: 
  - SA1B格式（RLE编码）
  - JSON格式（多边形标注）
  - PNG分割掩码

### 4.2 目录结构

```
dataset/
├── images/          # 图像文件
├── json/            # JSON标注文件
└── preprocessed_data/ # 预处理后的数据
```

### 4.3 数据集加载

- 使用数据加载器模式
- 支持多数据集混合加载
- 实现惰性加载以处理大型数据集

## 5. 开发工作流程和最佳实践

### 5.1 开发环境设置

- **推荐配置**:
  - Python 3.10+
  - PyTorch 2.5.1+
  - CUDA 12.1+
  - 至少16GB系统内存，推荐32GB+
  - 支持CUDA的GPU，推荐NVIDIA RTX系列或A系列

- **环境创建步骤**:
  ```bash
  # 使用conda创建环境
  conda create -n sam2 python=3.10
  conda activate sam2
  
  # 安装PyTorch和CUDA
  conda install pytorch=2.5.1 torchvision torchaudio pytorch-cuda=12.1 -c pytorch -c nvidia
  
  # 安装项目依赖
  pip install -e "[notebooks,interactive-demo,dev]"
  
  # 构建CUDA扩展
  pip install -e .
  ```

- **开发工具推荐**:
  - 编辑器: VS Code (推荐插件: Python, Pylance, Black, Pylint)
  - 版本控制: Git
  - 调试: ipdb, VS Code调试器
  - 性能分析: PyTorch Profiler

### 5.2 代码开发流程

1. **需求分析与规划**:
   - 明确功能需求和技术要求
   - 评估对现有代码的影响范围
   - 制定详细的开发计划和测试策略

2. **环境准备**:
   - 克隆代码仓库
   - 创建并配置开发环境
   - 确保通过所有现有测试

3. **代码编写**:
   - 遵循项目编码规范
   - 实现功能并编写相应的单元测试
   - 添加必要的文档和注释
   - 使用适当的设计模式和架构原则

4. **本地测试**:
   - 运行单元测试验证功能正确性
   - 进行集成测试确保与现有系统兼容
   - 检查代码覆盖率
   - 进行性能测试和内存使用分析

5. **代码审查准备**:
   - 运行代码格式化工具 (Black)
   - 执行静态代码分析 (Pylint)
   - 确保没有未解决的警告或错误

6. **提交代码**:
   - 编写清晰、描述性的提交信息
   - 提交消息格式: `[类型]: 简短描述`
     - `feat`: 新功能
     - `fix`: 错误修复
     - `docs`: 文档更新
     - `style`: 代码风格修改
     - `refactor`: 代码重构
     - `perf`: 性能优化
     - `test`: 测试相关

7. **创建合并请求**:
   - 详细描述变更内容和目的
   - 提供相关测试结果
   - 等待代码审查

8. **代码审查与迭代**:
   - 根据反馈修改代码
   - 确保所有测试通过
   - 更新相关文档

9. **合并与部署**:
   - 合并代码到目标分支
   - 更新版本号（如需要）
   - 部署（如适用）

### 5.3 分支管理策略

- **分支命名规则**:
  - `main`: 主分支，保持稳定和可发布状态
  - `dev`: 开发分支，集成所有功能分支
  - `feature/功能名`: 新功能开发分支
  - `bugfix/问题描述`: 错误修复分支
  - `hotfix/版本号`: 紧急修复生产环境问题
  - `docs/文档名`: 文档更新分支

- **分支生命周期**:
  1. 从`dev`分支创建新分支
  2. 完成开发和测试
  3. 创建合并请求到`dev`分支
  4. 通过代码审查后合并
  5. 定期从`dev`合并到`main`并发布版本

- **合并策略**:
  - 使用Squash Merge减少提交历史混乱
  - 合并前确保代码通过所有测试
  - 大型合并前进行集成测试

### 5.4 代码审查指南

- **审查者职责**:
  - 检查代码是否符合项目规范
  - 验证功能实现的正确性和完整性
  - 评估代码的性能和可扩展性
  - 检查潜在的安全问题
  - 提供建设性的反馈和改进建议

- **审查清单**:
  1. 代码风格是否符合项目规范
  2. 文档是否完整且最新
  3. 是否包含适当的测试
  4. 错误处理是否完善
  5. 是否有性能优化空间
  6. 是否存在潜在的安全风险
  7. 与现有代码的兼容性

- **审查流程**:
  1. 初检：基本格式和规范检查
  2. 功能审查：实现逻辑和功能正确性
  3. 代码质量审查：架构、可读性和可维护性
  4. 测试审查：测试覆盖和测试质量
  5. 反馈和修订：提供反馈并跟进修改

### 5.5 测试策略

- **测试类型**:
  - **单元测试**：测试单个函数或类
  - **集成测试**：测试多个组件协同工作
  - **性能测试**：测试模型和算法性能
  - **内存测试**：检查内存泄漏和使用效率

- **测试编写指南**:
  - 使用pytest框架
  - 测试文件命名：`test_*.py`
  - 测试函数命名：`test_函数名`
  - 每个测试应独立且可重复
  - 测试应覆盖正常路径和异常路径

- **测试覆盖率目标**:
  - 核心模型代码：>80%
  - API接口：>90%
  - 工具函数：>70%

### 5.6 性能优化最佳实践

- **GPU内存优化**:
  - 使用混合精度训练（FP16）
  - 合理使用梯度累积
  - 及时释放不再使用的张量
  - 避免不必要的大型中间结果

- **计算效率优化**:
  - 使用PyTorch的JIT编译（`torch.jit.script`）
  - 利用CUDA扩展加速关键操作
  - 合理设置批处理大小
  - 使用高效的数据结构和算法

- **分布式训练**:
  - 使用PyTorch DDP进行多GPU训练
  - 配置合理的通信策略
  - 优化数据加载和预处理管道
  - 监控训练进度和资源使用

### 5.7 常见问题排查指南

- **CUDA错误排查**:
  - 检查CUDA版本兼容性
  - 验证GPU内存是否充足
  - 检查CUDA扩展是否正确编译
  - 使用`torch.cuda.is_available()`和`torch.cuda.current_device()`诊断

- **内存泄漏排查**:
  - 使用PyTorch Profiler分析内存使用
  - 检查未释放的大型张量
  - 监控长期运行进程的内存增长

- **性能问题排查**:
  - 识别瓶颈操作（使用Profiler）
  - 检查数据加载是否成为瓶颈
  - 验证模型计算图优化
  - 监控GPU利用率和温度

### 5.8 文档维护最佳实践

- **文档更新时机**:
  - 新功能实现后立即更新
  - API变更时同步更新文档
  - 发现文档错误时及时修正

- **文档类型**:
  - 技术文档：架构设计、API参考
  - 使用文档：快速入门、使用指南
  - 示例文档：代码示例、使用场景
  - 维护文档：故障排除、升级指南

- **文档工具**:
  - API文档：Sphinx + NumPy风格文档字符串
  - 教程和指南：Jupyter notebooks
  - 项目说明：Markdown文档

## 6. 模型开发规范

### 6.1 模型扩展

- 遵循现有架构模式
- 扩展时保持API兼容性
- 新增组件应有明确的接口定义

### 6.2 训练最佳实践

- 使用分布式训练加速
- 实现适当的学习率调度
- 设置检查点保存机制
- 添加日志记录

### 6.3 推理优化

- 使用`torch.compile`进行优化
- 考虑内存效率
- 支持批处理和流式处理

## 7. 文档规范

### 7.1 README要求

- 项目概述
- 安装说明
- 快速开始
- 主要功能介绍
- 常见问题

### 7.2 API文档

- 使用Sphinx生成API文档
- 所有公共API应有详细文档
- 提供使用示例

### 7.3 示例文档

- Jupyter笔记本形式
- 包含完整工作流程
- 解释关键概念

## 8. 团队协作规范

### 8.1 沟通渠道

- 代码审查评论
- 技术文档更新
- 定期团队同步

### 8.2 版本控制

- 语义化版本控制
- 发布前进行全面测试
- 维护CHANGELOG

### 8.3 知识分享

- 新功能开发后更新文档
- 复杂实现添加设计说明
- 团队内部技术分享

## 9. 安全与性能考虑

### 9.1 安全规范

- 避免硬编码敏感信息
- 数据处理时注意隐私保护
- 输入验证和错误处理

### 9.2 性能优化

- GPU内存使用优化
- 计算效率考虑
- 大型模型的量化和蒸馏

## 10. 附录

### 10.1 技术栈依赖

- **核心**: Python 3.10+, PyTorch 2.5.1+, CUDA
- **数据处理**: NumPy, PIL, OpenCV
- **配置管理**: Hydra
- **Web演示**: Flask, React
- **开发工具**: Black, Jupyter

### 10.2 常见问题解答

- 安装问题排查
- 配置文件格式说明
- 性能优化建议

---

*本规范基于SAM2项目现有结构制定，旨在统一开发标准，提高代码质量和团队协作效率。*